import { supabase } from './supabase';
import { v4 as uuidv4 } from 'uuid';
import { Memory } from '@/components/MemoryList';

// Types for the database
export type DbMemory = {
  id: string;
  access_code: string;
  media_url?: string;
  caption?: string;
  event_date: string;
  location?: string;
  likes?: number;
  is_video?: boolean;
  is_liked?: boolean;
};

export type AccessCode = {
  code: string;
  name: string;
  created_at: string;
};

export type Board = {
  id: string;
  name: string;
  created_at: string;
  access_code: string;
  owner_id?: string;
  share_code: string; // Every board now has its own share code
};

export type BoardMember = {
  id: string;
  board_id: string;
  user_id: string;
  role: 'owner' | 'member';
  joined_at: string;
};

// Convert database memory to frontend memory
export const dbMemoryToMemory = (dbMemory: DbMemory): Memory => {
  return {
    id: dbMemory.id,
    image: dbMemory.media_url || '',
    caption: dbMemory.caption,
    date: dbMemory.event_date ? new Date(dbMemory.event_date) : new Date(),
    location: dbMemory.location,
    likes: dbMemory.likes || 0,
    isLiked: dbMemory.is_liked || false,
    isVideo: dbMemory.is_video,
    type: 'memory',
    accessCode: dbMemory.access_code,
  };
};

// Convert frontend memory to database memory
export const memoryToDbMemory = (memory: Memory): Omit<DbMemory, 'created_at'> => {
  return {
    id: memory.id,
    access_code: memory.accessCode,
    media_url: memory.image,
    caption: memory.caption,
    event_date: memory.date.toISOString(),
    location: memory.location,
    likes: memory.likes,
    is_video: memory.isVideo,
    is_liked: memory.isLiked,
  };
};

// Board operations
export const fetchBoards = async (): Promise<Board[]> => {
  try {
    const {
      data: { user },
      error: userError
    } = await supabase.auth.getUser();

    if (userError || !user) throw new Error('User not authenticated');

    // First get the board IDs where the user is a member
    const { data: membershipData, error: membershipError } = await supabase
      .from('board_members')
      .select('board_id, role')
      .eq('user_id', user.id);

    if (membershipError) throw membershipError;

    if (!membershipData || membershipData.length === 0) {
      return [];
    }

    const boardIds = membershipData.map(membership => membership.board_id);

    // Then fetch the boards using the board IDs
    const { data, error } = await supabase
      .from('boards')
      .select('*')
      .in('id', boardIds)
      .order('created_at', { ascending: false });

    if (error) throw error;
    return data as Board[];
  } catch (error) {
    console.error('Error fetching boards:', error);
    return [];
  }
};

export const getBoardById = async (boardId: string): Promise<Board | null> => {
  try {
    const {
      data: { user },
      error: userError
    } = await supabase.auth.getUser();

    if (userError || !user) throw new Error('User not authenticated');

    // First check if user is a member of this board
    const { data: membershipData, error: membershipError } = await supabase
      .from('board_members')
      .select('role')
      .eq('user_id', user.id)
      .eq('board_id', boardId)
      .maybeSingle();

    if (membershipError || !membershipData) {
      throw new Error('User is not a member of this board');
    }

    // Then fetch the board
    const { data, error } = await supabase
      .from('boards')
      .select('*')
      .eq('id', boardId)
      .maybeSingle();

    if (error) throw error;
    return data as Board;
  } catch (error) {
    console.error('Error fetching board by ID:', error);
    return null;
  }
};

export const getBoardByShareCode = async (shareCode: string): Promise<Board | null> => {
  try {
    const { data, error } = await supabase
      .from('boards')
      .select('*')
      .eq('share_code', shareCode)
      .single();

    if (error) throw error;
    return data as Board;
  } catch (error) {
    console.error('Error fetching board by share code:', error);
    return null;
  }
};

export const createBoard = async (name: string): Promise<Board | null> => {
  try {
    const {
      data: { user },
      error: userError
    } = await supabase.auth.getUser();

    if (userError || !user) throw new Error('User not authenticated');

    const accessCode = Math.random().toString(36).substring(2, 8).toUpperCase();
    
    // First create the access code
    const { error: accessCodeError } = await supabase
      .from('access_codes')
      .insert([{ code: accessCode, name }]);

    if (accessCodeError) throw accessCodeError;

    // Then create the board (share_code will be auto-generated by trigger)
    const { data, error } = await supabase
      .from('boards')
      .insert([{ 
        name, 
        access_code: accessCode,
        owner_id: user.id 
      }])
      .select()
      .single();

    if (error) throw error;
    return data as Board;
  } catch (error) {
    console.error('Error creating board:', error);
    return null;
  }
};

export const addUserToBoard = async (shareCode: string): Promise<{ success: boolean; board?: Board; message: string }> => {
  try {
    const {
      data: { user },
      error: userError
    } = await supabase.auth.getUser();

    if (userError || !user) {
      return { success: false, message: 'User not authenticated' };
    }

    // First check if the board exists
    const board = await getBoardByShareCode(shareCode);
    if (!board) {
      return { success: false, message: 'Board not found with this share code' };
    }

    // Check if user is already a member
    const { data: existingMember } = await supabase
      .from('board_members')
      .select('*')
      .eq('board_id', board.id)
      .eq('user_id', user.id)
      .single();

    if (existingMember) {
      return { success: true, board, message: 'You are already a member of this board' };
    }

    // Add user to the board
    const { error } = await supabase
      .from('board_members')
      .insert([{
        board_id: board.id,
        user_id: user.id,
        role: 'member'
      }]);

    if (error) throw error;

    return { success: true, board, message: 'Successfully joined the board!' };
  } catch (error) {
    console.error('Error adding user to board:', error);
    return { success: false, message: 'Failed to join board' };
  }
};

export const deleteBoard = async (boardId: string): Promise<{ success: boolean; message: string }> => {
  try {
    const {
      data: { user },
      error: userError
    } = await supabase.auth.getUser();

    if (userError || !user) throw new Error('User not authenticated');

    // First, remove the user from the board
    const { error: removeMemberError } = await supabase
      .from('board_members')
      .delete()
      .eq('board_id', boardId)
      .eq('user_id', user.id);

    if (removeMemberError) throw removeMemberError;

    // Check if there are any remaining members
    const { data: remainingMembers, error: membersError } = await supabase
      .from('board_members')
      .select('id')
      .eq('board_id', boardId);

    if (membersError) throw membersError;

    // If no members remain, delete the entire board and its data
    if (!remainingMembers || remainingMembers.length === 0) {
      // Get the board's access code for cleanup
      const { data: boardData } = await supabase
        .from('boards')
        .select('access_code')
        .eq('id', boardId)
        .single();

      // Delete all memories associated with the board
      if (boardData?.access_code) {
        const { error: memoriesError } = await supabase
          .from('memories')
          .delete()
          .eq('access_code', boardData.access_code);

        if (memoriesError) throw memoriesError;

        // Delete the access code
        const { error: accessCodeError } = await supabase
          .from('access_codes')
          .delete()
          .eq('code', boardData.access_code);

        if (accessCodeError) throw accessCodeError;
      }

      // Finally delete the board itself
      const { error: boardError } = await supabase
        .from('boards')
        .delete()
        .eq('id', boardId);

      if (boardError) throw boardError;

      return { success: true, message: 'Board deleted completely as you were the last member' };
    } else {
      return { success: true, message: 'You have been removed from the board' };
    }
  } catch (error) {
    console.error('Error removing user from board:', error);
    return { success: false, message: 'Failed to remove user from board' };
  }
};

// Memory operations
export const fetchMemories = async (accessCode: string): Promise<Memory[]> => {
  try {
    const { data, error } = await supabase
      .from('memories')
      .select('*')
      .eq('access_code', accessCode)
      .order('event_date', { ascending: false });

    if (error) throw error;
    return (data as DbMemory[]).map(dbMemoryToMemory);
  } catch (error) {
    console.error('Error fetching memories:', error);
    return [];
  }
};

export const getMemory = async (id: string, accessCode: string): Promise<Memory | null> => {
  try {
    const { data, error } = await supabase
      .from('memories')
      .select('*')
      .eq('id', id)
      .eq('access_code', accessCode)
      .single();

    if (error) throw error;
    return data ? dbMemoryToMemory(data as DbMemory) : null;
  } catch (error) {
    console.error('Error fetching memory:', error);
    return null;
  }
};

export const createMemory = async (memory: Memory): Promise<Memory | null> => {
  try {
    const newDbMemory = memoryToDbMemory(memory);
    const { data, error } = await supabase
      .from('memories')
      .insert([newDbMemory])
      .select()
      .single();

    if (error) throw error;
    return dbMemoryToMemory(data as DbMemory);
  } catch (error) {
    console.error('Error creating memory:', error);
    return null;
  }
};

export const updateMemory = async (memory: Memory): Promise<Memory | null> => {
  try {
    const dbMemory = memoryToDbMemory(memory);
    const { data, error } = await supabase
      .from('memories')
      .update(dbMemory)
      .eq('id', memory.id)
      .eq('access_code', memory.accessCode)
      .select()
      .single();

    if (error) throw error;
    return dbMemoryToMemory(data as DbMemory);
  } catch (error) {
    console.error('Error updating memory:', error);
    return null;
  }
};

export const deleteMemory = async (memoryId: string, accessCode: string): Promise<boolean> => {
  try {
    const { error } = await supabase
      .from('memories')
      .delete()
      .eq('id', memoryId)
      .eq('access_code', accessCode);

    if (error) throw error;
    return true;
  } catch (error) {
    console.error('Error deleting memory:', error);
    return false;
  }
};